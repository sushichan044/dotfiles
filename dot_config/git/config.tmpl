{{- if eq .chezmoi.username "sushi" "sushichan044" -}}
[user]
{{- if .for_personal }}
signingkey = {{ onepasswordRead "op://dotfiles/Github-Commit-Sign/public key" }}
{{- else }}
signingkey = {{ onepasswordRead "op://Employee/Github-Commit-Sign/public key" }}
{{- end }}

[include]
path = ~/.config/git/config.d/ghq.conf
path = ~/.config/git/config.d/user.github.conf
{{- end }}

[branch]
sort = -committerdate

[color]
ui = true
diff = auto
status = auto
branch = auto

[column]
ui = auto

[commit]
verbose = true

[core]
autocrlf = input
fsmonitor = true
ignorecase = false
pager = delta
untrackedCache = true

[delta]
navigate = true

[diff]
algorithm = histogram
colorMoved = true
mnemonicPrefix = true
renames = true

[fetch]
prune = true
pruneTags = true
all = true

[feature]
experimental = true

[help]
autocorrect = prompt

[init]
defaultBranch = main

[interactive]
diffFilter = delta --color-only

[merge]
conflictStyle = zdiff3

[push]
autoSetupRemote = true
default = simple
followTags = true

[pull]
autoStash = true
rebase = true

[rebase]
autoStash = true
autoSquash = true
updateRefs = true

[rerere]
autoupdate = true
enabled = true

[tag]
sort = version:refname

[filter "lfs"]
process = git-lfs filter-process
required = true
clean = git-lfs clean -- %f
smudge = git-lfs smudge -- %f

[alias]
cz = "!f() { git-cz }; f"
clear-cache = "rm -r --cached ."
com = "!f() { remote_head=$(git symbolic-ref --quiet refs/remotes/origin/HEAD); remote_head=${remote_head#refs/remotes/origin/}; git checkout ${remote_head:-$(git rev-parse --symbolic --verify --quiet main || git rev-parse --symbolic --verify --quiet master)}; }; f"
fixit = "commit --amend --no-edit"
fixup = "commit --fixup"
apply-fixup = "!f() { git rebase -i --autosquash $1^; }; f"
bk = "!f() { git switch -c $(git branch --show-current)-$(TZ=UTC-9 date +'%Y%m%d%H%M'); }; f"
f = "fetch"
rm-merged-branch = "!git branch --merged | grep -v '^*' | grep -v 'master' | xargs git branch -d"
# rebase current branch with origin/HEAD
rbm = "!f() { \
    CURRENT_BRANCH=$(git branch --show-current); \
    git stash push --include-untracked -m \"Auto stash before rebase of $CURRENT_BRANCH\"; \
    git fetch origin && git rebase $(git rev-parse --abbrev-ref origin/HEAD | sed 's/origin\\///') && git stash pop || { echo 'Conflict occurred during rebase. Please run `git rebase --continue` and then `git stash pop` after resolving conflicts.'; return 1; }; \
}; f"

# Worktree aliases
wt = worktree
wtc = "!f() { \
    current_branch=$(git branch --show-current); \
    if [ -z \"$current_branch\" ]; then \
        echo \"Error: Not on a branch (detached HEAD). Please checkout a branch first.\"; \
        return 1; \
    fi; \
    echo \"Creating worktree from current branch: $current_branch\"; \
    repo_dir=$(git rev-parse --show-toplevel); \
    repo_name=$(basename \"${repo_dir}\"); \
    safe_branch=$(echo \"$current_branch\" | sed 's/[^a-zA-Z0-9._-]/-/g'); \
    tree_name=${safe_branch}-$(TZ=UTC-9 date +'%Y%m%d%H%M%S'); \
    dir_name=\"${repo_name}-worktree-${tree_name}\"; \
    if git worktree add -b \"${tree_name}\" \"${dir_name}\"; then \
        echo \"Successfully created worktree: ${tree_name}\"; \
        if command -v pbcopy >/dev/null 2>&1; then \
            echo \"${dir_name}\" | pbcopy && echo \"Worktree path automatically copied: ${dir_name}\"; \
        fi; \
    else \
        echo \"Failed to create worktree\"; \
        return 1; \
    fi; \
}; f"
# Create worktree from GitHub PR number
wtp = "!f() { \
    if [ -z \"$1\" ]; then \
        echo \"Usage: git wtp <PR-number>\"; \
        return 1; \
    fi; \
    pr_branch=$(gh pr view $1 --json headRefName --jq '.headRefName' 2>/dev/null); \
    if [ -z \"$pr_branch\" ]; then \
        echo \"Failed to get PR branch name for PR #$1. Make sure the PR exists and you have access.\"; \
        return 1; \
    fi; \
    echo \"Fetching PR #$1 (branch: $pr_branch)...\"; \
    if ! gh pr checkout $1; then \
        echo \"Failed to checkout PR #$1\"; \
        return 1; \
    fi; \
    repo_dir=$(git rev-parse --show-toplevel); \
    repo_name=$(basename \"${repo_dir}\"); \
    tree_name=pr-$1-${pr_branch}-$(TZ=UTC-9 date +'%Y%m%d%H%M%S'); \
    dir_name=\"${repo_name}-worktree-${tree_name}\"; \
    if git worktree add \"${dir_name}\" \"${pr_branch}\"; then \
        echo \"Created worktree for PR #$1: ${tree_name}\"; \
        if command -v pbcopy >/dev/null 2>&1; then \
            echo \"${dir_name}\" | pbcopy && echo \"Worktree path automatically copied: ${dir_name}\"; \
        fi; \
    else \
        echo \"Failed to create worktree for PR #$1\"; \
        return 1; \
    fi; \
}; f"

# Commit signing
# Not configured for .ostype == "linux"
{{ if eq .ostype "darwin" -}}
[commit]
gpgsign = true
[gpg]
format = ssh
[gpg "ssh"]
program = "/Applications/1Password.app/Contents/MacOS/op-ssh-sign"
{{ else if eq .ostype "wsl" -}}
[commit]
gpgsign = true
[gpg]
format = ssh
[gpg "ssh"]
program = "/mnt/c/Program Files/1Password/app/8/op-ssh-sign-wsl"
{{ else if eq .ostype "windows" -}}
[commit]
gpgsign = true
[gpg]
format = ssh
[gpg "ssh"]
program = "C:/Program Files/1Password/app/8/op-ssh-sign.exe"
{{ end -}}
